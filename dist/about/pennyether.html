<!DOCTYPE html>
<html>
	<head>
		<script src="/javascripts/lib/Loader.js"></script>
		<script>
			Loader.onPageLoad.then(()=>{
				// animates an Ether icon from start to stop.
				function _sendEth(start, stop, doFadeOn, doFadeOff, size, timeMs) {
					return new Promise((resolve, reject)=>{
						const duration = timeMs || 1000;
						const $img = $("<img>")
							.attr("src", "/images/ethereum.png")
							.attr("width", size || 25)
							.css({
								opacity: 0,
								position: "absolute",
								top: -100,
								left: -100,
								background: "rgba(215,255,255,.9)",
								border: "1px solid #AAA",
								borderRadius: "40px",
								boxShadow: "0px 0px 10px 0px rgba(0,0,255,.5)",
								zIndex: 3
							})
							.appendTo(document.body);

						const startX = start.x;
						const startY = start.y
						const stopX = stop.x;
						const stopY = stop.y;

						const startTime = +new Date();
						window.requestAnimationFrame(function step(){
							const pct = Math.min((+new Date() - startTime) / duration, 1);
							const x = startX + pct*(stopX - startX);
							const y = startY + pct*(stopY - startY);
							var opacity = 1;
							if (pct < .5 && doFadeOn) opacity = pct*4;
							if (pct > .5 && doFadeOff) opacity = (1-pct)*4;
							$img.css({
								opacity: opacity,
								left: Math.round(x),
								top: Math.round(y)
							});
							if (pct < 1) window.requestAnimationFrame(step);
							else {
								setTimeout(function(){ $img.remove(); }, 0);
								resolve();
							}
						});
					});
				}

				// does the Overview animations
				(function(){
					const $top = $(".topology");
					var fundingStart, fundingStop;
					var fundGameStart, fundGameStop;
					var game1RevStart, game1RevStop;
					var game2RevStart, game2RevStop;
					var revTop, revEnd;
					var profitsStart, profitsStop;
					var dividendsStop;

					function updateHeights(){
						const trOffset = $top.find(".treasury").offset();
						const mcOffset = $top.find(".mc").offset();
						const gameOffset = $top.find(".games").offset();
						const game1Offset = $top.find(".game-1").offset();
						const game2Offset = $top.find(".game-2").offset();
						const game1lineOffset = $top.find(".game-1-line").offset();
						const game2lineOffset = $top.find(".game-2-line").offset();
						const revUpOffset = $top.find(".revenue-up-line").offset();
						const tokenOffset = $top.find(".token").offset();
						const holdersOffset = $top.find(".ths").offset();

						fundingStart = {x: trOffset.left + 30, y: trOffset.top + 60};
						fundingStop = {x: fundingStart.x, y: mcOffset.top + 41};
						fundGameStart = {x: fundingStop.x, y: fundingStop.y};
						fundGameStop = {x: gameOffset.left, y: fundGameStart.y};
						game1RevStart = {x: game1Offset.left + 65, y: game1Offset.top - 2};
						game1RevStop = {x: revUpOffset.left - 14, y: game1RevStart.y};
						game2RevStart = {x: game1RevStart.x, y: game2Offset.top - 2};
						game2RevStop = {x: game1RevStop.x, y: game2RevStart.y};
						revTop = {x: game2RevStop.x, y: revUpOffset.top - 13};
						revEnd = {x: trOffset.left + 300, y: revTop.y};
						profitsStart = {x: trOffset.left, y: trOffset.top + 80};
						profitsStop = {x: tokenOffset.left + 110, y: profitsStart.y};
						dividendsStop = {x: profitsStop.x + 20, y: holdersOffset.top + 35};
					};
					updateHeights();
					setInterval(updateHeights, 1000);

					function doFunding(){
						_sendEth(fundingStart, fundingStop, true)
							.then(() => _sendEth(fundGameStart, fundGameStop, false, true))
							.then(()=>{
								setTimeout(doFunding, 7000);			
							});
					}
					setTimeout(doFunding, 7000);

					function doRevenue(){
						var p;
						const queueNext = () => setTimeout(doRevenue, Math.random() * 2000);
						if (Math.random() < .5) {
							p = _sendEth(game1RevStart, game1RevStop, true)
								.then(queueNext)
								.then(() => _sendEth(game1RevStop, revTop));
						}else{
							p = _sendEth(game2RevStart, game2RevStop, true)
								.then(queueNext)
								.then(() => _sendEth(game2RevStop, revTop));
						}
						p.then(() => _sendEth(revTop, revEnd, false, true));
					}
					setTimeout(doRevenue, 1000);

					function doProfits(){
						_sendEth(profitsStart, profitsStop, true)
							.then(()=>{
								const promises = [];
								for (var i = 0; i<15; i++){
									const signX = Math.random()<.5 ? 1 : -1;
									const signY = Math.random()<.5 ? 1 : -1;
									const end = {
										x: dividendsStop.x + Math.random()*120*signX,
										y: dividendsStop.y + Math.random()*50*signY
									};
									const duration = 700 + Math.random()*1300;
									promises.push(_sendEth(profitsStop, end, false, true, 20, duration));
								}
								return Promise.all(promises);
							}).then(()=>{
								setTimeout(doProfits, 4000);
							});
					}
					setTimeout(doProfits, 4000);
				}());
				
				// does the Treasury animations
				(function(){
					function FinanceBar(){
						const _$e = $(`
							<div id="FinanceBar">
								<div class="bar" style="position: relative;">
									<div class="balanceBar" style="height: 100%; position: absolute;"></div>
									
									<div class="bankrollMarker" style="height: 100%; position: absolute;"></div>
									<div class="divThreshMarker" style="height: 100%; position: absolute;"></div>
									<div class="balanceMarker" style="height: 100%; position: absolute;"></div>

									<div class="balanceTxt" style="position: absolute; top: -20px;"></div>
									<div class="bankrollTxt" style="position: absolute; bottom: -20px;"></div>
									<div class="divThreshTxt" style="position: absolute; bottom: -35px;"></div>
								</div>
							</div>
						`);
						const _$balanceBar = _$e.find(".balanceBar");
						const _$balanceMarker = _$e.find(".balanceMarker");
						const _$bankrollMarker = _$e.find(".bankrollMarker");
						const _$divThreshMarker = _$e.find(".divThreshMarker");

						const _$balanceTxt = _$e.find(".balanceTxt")
							.attr("title", "The amount of ETH Treasury is holding.")
							.addClass("tipRight");
						const _$bankrollTxt = _$e.find(".bankrollTxt")
							.attr("title", "The amount of ETH token holders have staked. If balance is above this, all token holder's ETH is safe.")
							.addClass("tipRight");
						const _$divThreshTxt = _$e.find(".divThreshTxt")
							.attr("title", "Any balance above this amount can be distributed as dividends.")
							.addClass("tipRight");

						tippy(_$balanceTxt[0], {placement: "top"});
						tippy([_$bankrollTxt[0], _$divThreshTxt[0]], {placement: "bottom"});

						this.$e = _$e;
						this.setValues = function(balance, bankroll, divThreshold){
							// calculate max number, add 10%
							const max = new BigNumber(800e18);
							const width = _$e.find(".bar").width();
							function toPct(val) {
								return val.div(max).mul(width).round().toNumber();
							}
							const balancePct = toPct(balance);
							const bankrollPct = toPct(bankroll);
							const threshPct = toPct(divThreshold);

							// make the bankground change
							(function(){
								const bankrollColor = `rgba(0,200,0,.8)`;
								const threshColor = `rgba(0,240,0,.8)`;
								const profitColor = `rgba(0,255,0,1)`;
								const bands = [];
								bands.push(`${bankrollColor} 0%`);
								bands.push(`${bankrollColor} ${bankrollPct}px`);
								bands.push(`${threshColor} ${bankrollPct+3}px`);
								bands.push(`${threshColor} ${threshPct}px`);
								bands.push(`${profitColor} ${threshPct+3}px`);
								const gradient = `linear-gradient(to right, ${bands.join(", ")})`;
								_$balanceBar.css("background", gradient);
							}());

							_$balanceMarker.width(`${balancePct}px`);
							_$bankrollMarker.width(`${bankrollPct}px`);
							_$divThreshMarker.width(`${threshPct}px`);
							_$balanceTxt.css("left", `${balancePct}px`)
								.text("↓ Balance: " + ethUtil.toEthStr(balance,0));
							_$bankrollTxt.css("left", `${bankrollPct}px`)
								.text("↑ Bankroll: " + ethUtil.toEthStr(bankroll,0));
							_$divThreshTxt.css("left", `${threshPct}px`)
								.text("↑ Dividend Threshold: " + ethUtil.toEthStr(divThreshold,0));

							_$balanceBar.width(balancePct);
						}
					}
					const $sim = $("#tr-sim");
					const bar = new FinanceBar();
					bar.$e.appendTo($sim.find(".bar-placeholder"));
					const $txtBalance = bar.$e.find(".balanceTxt");
					const $txtBankroll = bar.$e.find(".bankrollTxt");
					const $txtDivThresh = bar.$e.find(".divThreshTxt");
					const $dfl = $sim.find(".treasury .dailyFundingLimit");
					const $dflLabel = $dfl.find(".label");
					const $dflValue = $dfl.find(".value");
					const $investors = $sim.find(".investors").addClass("show");
					const $crowdsale = $sim.find(".crowdsale").addClass("show");
					const $token = $sim.find(".token").addClass("show");
					const $pa1 = $sim.find(".pennyauction1");
					const $pa2 = $sim.find(".pennyauction2");
					const $instadice = $sim.find(".instadice");
					const $extra = $sim.find(".extra");

					const $status = $("#tr-sim .status");
					const $statusTxt = $("#tr-sim .status .left");
					const $statusBtn = $("#tr-sim .status button").click(nextStep);

					function updateBar(){
						bar.setValues(balance, bankroll, divThreshold);
					}

					var step, bankroll, balance, divThreshold;
					function reset() {
						step = 0;
						bankroll = new BigNumber(0);
						balance = new BigNumber(0);
						divThreshold = new BigNumber(0);
						$pa1.removeClass("show");
						$pa2.removeClass("show");
						$instadice.removeClass("show");
						$extra.css({opacity: 0});
						$crowdsale.css({opacity: ""});
						$txtBankroll.hide();
						$txtDivThresh.hide();
						$dfl.hide();
						nextStep();
					}
					function nextStep(){
						const next = steps[step];
						if (!next) return reset();
						steps[step]();
						step++;
					}
					function wait(timeMs){
						$statusBtn.attr("disabled", "disabled").css("opacity", .4);
						return new Promise((res,rej)=>{
							setTimeout(()=>{
								$statusBtn.removeAttr("disabled", "disabled").css("opacity","");
								res();
							}, timeMs);
						});
					}
					const steps = [
						function step0a() {
							updateBar();
							$statusBtn.text("Continue");
							$statusTxt.empty()
								.append(`Prior to the CrowdSale, the Treasury will be funded by the owners.<br>
										The owners will fund the Treasury so that games can be run.`);
						},
						function step0b() {
							balance = balance.plus(100e18);
							updateBar();
							wait(2000).then(()=>{
								$statusBtn.text("Continue");
								$statusTxt.empty()
									.append(`In this example, the owners have added 100 Ether to the Treasury.<br>
											The owners have full control over this Ether, until the CrowdSale starts.<br>
											<b>Let's start the CrowdSale!</b>`);
							});
						},
						function step0b() {
							$txtBankroll.show();
							setTimeout(()=>$txtBankroll.addClass("on"),100);
							$statusBtn.text("Start CrowdSale");
							$statusTxt.empty()
								.append(`The CrowdSale will fund the Treasury with .5 Ether per Token minted, as <span class="code">bankroll</span>.<br>
									 	In this example, the CrowdSale mints 1000 Tokens, so the bankroll will be <span class="code">500 Ether</span>.`);
							
						},
						function step1(){
							const invOffset = $investors.offset();
							const csOffset = $crowdsale.offset();
							const invPt = {x: invOffset.left + 40, y: invOffset.top};
							const invHeight = $investors.height();
							const csPt = {x: csOffset.left + 40, y: invPt.y};
							const trPt = {x: csPt.x, y: csPt.y - 100};
							// send 10 eth icons from investors to crowdsale.
							for (var i=0; i<20; i++) {
								const start = {x: invPt.x, y: invPt.y + Math.random()*invHeight};
								const stop = {x: csPt.x, y: start.y};
								const timeMs = 500 + Math.random()*1000;
								setTimeout(()=>{
									_sendEth(start, stop, true, true, 10, timeMs);	
								}, Math.random()*1500);
							}
							wait(3000).then(()=>{
								_sendEth(csPt, trPt, true, true);
								return wait(1000);
							}).then(()=>{
								bankroll = new BigNumber(500e18);
								balance = new BigNumber(500e18);
								divThreshold = new BigNumber(500e18);
								updateBar();
								return wait(2500);
							}).then(()=>{
								$statusBtn.text("Continue");
								$statusTxt.empty()
									.append(`The <span class="code">bankroll</span> is now 500 Ether.<br>
											As long as the Treasury balance is above this value,<br>
											all tokens can be burned for refund of .5 Ether each.`);
							});
						},
						function step2(){
							$txtBankroll.removeClass("on");
							wait(1000).then(()=>{
								$dfl.show();
								setTimeout(()=>$dflLabel.addClass("on"), 100);
								$statusBtn.text("Set dailyFundingLimit");
								$statusTxt.empty()
									.append(`The Treasury has a variable called <span class="code">dailyFundingLimit</span>.<br>
										This is the amount of Ether that the Treasury can spend each day.<br>
										This ensures nobody can steal from the Treasury.<br>
										<b>Let's set this value to 5 Ether.</b>
									`);
							})
						},
						function step3(){
							$dflLabel.removeClass("on");
							$dflValue.addClass("on").text("5 Ether");
							wait(1000).then(()=>{
								$txtDivThresh.show().addClass("on");
								divThreshold = divThreshold.plus(60e18);
								updateBar();
								return wait(2000);
							}).then(()=>{
								$statusBtn.text("Finish CrowdSale");
								$statusTxt.empty()
									.append(`Notice the <span class="code">Dividend Threshold</span> marker.<br>`)
									.append(`Its value is hardcoded to <span class="code">bankroll + 14 * dailyFundingLimit</span>.<br>`)
									.append(`Any balance above this is considered profit, and will be sent to DividendToken.<br>`)
									.append(`<b>The CrowdSale will send Ether to meet this amount.</b>`);
							});
						},
						function step4(){
							const csOffset = $crowdsale.offset();
							const csPt = {x: csOffset.left + 40, y: csOffset.top + 10};
							const trPt = {x: csPt.x, y: csPt.y - 100};
							_sendEth(csPt, trPt, true, true);
							wait(1000).then(()=>{
								balance = balance.plus(60e18);
								updateBar();
								return wait(2000);
							}).then(()=>{
								$txtDivThresh.removeClass("on");
								$txtBalance.addClass("on");
								$txtBankroll.addClass("on");
								$statusBtn.text("Continue");
								$statusTxt.empty()
									.append(`Since the most Treasury can lose per day is <span class="code">dailyFundingLimit</span>,<br>
										Tokens are fully collateralized for at least 14 days.`);
							});
						},
						function step5(){
							$txtBalance.removeClass("on");
							$txtBankroll.removeClass("on");
							$dflValue.removeClass("on");
							$crowdsale.css("opacity", .5);
							wait(1000).then(()=>{
								$statusBtn.text("Start a Penny Auction");
								$statusTxt.empty()
									.append(`The CrowdSale is complete!<br>
											Now let's see what happens when the Treasury funds a game.<br>
											<b>Let's start a Penny Auction with a 5 Ether prize.</b>`);
							});
						},
						function step6(){
							$txtBalance.addClass("on");
							balance = balance.minus(5e18);
							updateBar();
							wait(2000).then(()=>{
								$txtBalance.removeClass("on");
								const paOffset = $pa1.offset();
								const start = {x: paOffset.left+20, y: paOffset.top-100};
								const stop = {x: start.x, y: paOffset.top+20};
								$pa1.addClass("show");
								_sendEth(start, stop, true, true);
								return wait(1000);
							}).then(()=>{
								$statusBtn.text("Continue");
								$statusTxt.empty()
									.append(`Treasury balance has decreased by 5 Ether.<br>
											The Treasury will not be able to fund any other games until the next day.<br>`);
							});
						},
						function step6b(){
							$statusBtn.text("Collect Revenue");
							$statusTxt.empty()
								.append(`The Penny Auction will periodically send its revenue to Treasury.<br>
											Ideally, it produces more than 5 Ether in revenue.<br>
											<b>In this example, let's assume it collects 10 Ether</b>.`);
						},
						function step7(){
							const paOffset = $pa1.offset();
							const paPt = {x: paOffset.left, y: paOffset.top+30};
							const paWidth = $pa1.width();
							for (var i=0; i<9; i++) {
								const start = {x: paOffset.left + Math.random()*paWidth, y: paPt.y};
								const stop = {x: start.x, y: start.y-100};
								setTimeout(()=>{
									_sendEth(start, stop, true, true, 10);	
								}, i*200);
							}
							wait(2000).then(()=>{
								$txtBalance.addClass("on");
								balance = balance.plus(10e18);
								updateBar();
								return wait(2000);
							}).then(()=>{
								$statusBtn.text("Distribute Profits");
								$statusTxt.empty()
									.append(`<b>The Treasury now has a profit!</b><br>
											Profits get distributed <i>only</i> to the DividendToken.<br>
											Dividends can happen at any time, there is are no "distribution periods".<br>
											Investors will be able to collect their profit share, at any time, forever.<br>
											`);
							});
						},
						function step8(){
							const invOffset = $investors.offset();
							const tokenOffset = $token.offset();
							const tokenPt = {x: tokenOffset.left + 20, y: tokenOffset.top}
							const tokenHeight = $token.height();
							const invPt = {x: invOffset.left + 20, y: tokenPt.y};
							const trPt = {x: tokenPt.x, y: tokenPt.y - 100};
							balance = balance.minus(5e18);
							updateBar();
							wait(2000).then(()=>{
								_sendEth(trPt, tokenPt, true, true);
								return wait(1000);
							}).then(()=>{
								for (var i=0; i<20; i++){
									const start = {x: tokenPt.x, y: tokenOffset.top + Math.random()*tokenHeight};
									const stop = {x: invPt.x, y: start.y};
									setTimeout(()=>{
										_sendEth(start, stop, true, true, 10);
									}, Math.random()*2000)
								}
								return wait(3000);
							}).then(()=>{
								$txtDivThresh.addClass("on");
								$statusBtn.text("Continue");
								$statusTxt.empty()
									.append(`The Treasury has distributed profits.<br>
										When profits are distributed, Treasury balance will drop to <span class="code">Dividend Threshold</span>.<br>
										All tokens are still burnable for at least 14 days.`);
							});
						},
						function step9(){
							$txtBalance.removeClass("on");
							$txtDivThresh.removeClass("on");
							$statusBtn.text("Start another auction");
							$statusTxt.empty()
								.append(`More than one Penny Auction can be started at once.<br>
										For now, the admin sets how many auctions can run at once.<br>
										In the future, a DAO will decide.<br>
										<b>Let's start another Penny Auction</b>`);
						},
						function step10(){
							$txtBalance.addClass("on");
							balance = balance.minus(5e18);
							updateBar();
							wait(2000).then(()=>{
								$txtBalance.removeClass("on");
								const paOffset = $pa2.offset();
								const start = {x: paOffset.left+20, y: paOffset.top-100};
								const stop = {x: start.x, y: paOffset.top+20};
								$pa2.addClass("show");
								_sendEth(start, stop, true, true);
								return wait(1000);
							}).then(()=>{
								$statusBtn.text("Continue");
								$statusTxt.empty()
									.append(`A second Penny Auction is now running!`);
							});
						},
						function step10a(){
							$pa1.addClass("ended");
							$statusBtn.text("Continue");
							$statusTxt.empty()
								.append(`When a Penny Auction completes, it must be "finalized".<br>
										Finalizing a Penny Auction pays the winner, and allows it to be restarted.<br>
										`);
						},
						function step10b(){
							$statusBtn.text("End and Restart Auction");
							$statusTxt.empty()
								.append(`Both finalizing and restarting a Penny Auction are autonomous:<br>
										Any user can finalize and restart a Penny Auction, and is paid a reward to do so.<br>
										This ensures Penny Auctions run autonomously, without owner intervention.`);
						},
						function step10c(){
							balance = balance.minus(5e18);
							updateBar();
							wait(2000).then(()=>{
								const paOffset = $pa1.offset();
								const start = {x: paOffset.left+20, y: paOffset.top-100};
								const stop = {x: start.x, y: paOffset.top+20};
								_sendEth(start, stop, true, true);
								return wait(1000);
							}).then(()=>{
								$pa1.removeClass("ended");
								return wait(1000);
							}).then(()=>{
								$statusBtn.text("Continue");
								$statusTxt.empty()
									.append(`The Penny Auction has been finalized and restarted.`);
							});
						},
						function step11a(){
							$statusBtn.text("Continue");
							$statusTxt.empty()
								.append(`PennyEther was designed with scalability in mind.<br>
										New game types can be easily added.<br>
										<b>Let's add another Game Type</b>`)
						},
						function step11b(){
							$instadice.addClass("show");
							wait(1000).then(()=>{
								$statusBtn.text("Fund InstaDice");
								$statusTxt.empty()
									.append(`Now that we have a new game, let's fund it.`);
							});
						},
						function step12(){
							$txtBalance.addClass("on");
							balance = balance.minus(5e18);
							updateBar();
							wait(2000).then(()=>{
								$txtBalance.removeClass("on");
								const idOffset = $instadice.offset();
								const start = {x: idOffset.left+20, y: idOffset.top-100};
								const stop = {x: start.x, y: idOffset.top+20};
								_sendEth(start, stop, true, true);
								return wait(1000);
							}).then(()=>{
								$statusBtn.text("Collect Profits");
								$statusTxt.empty()
									.append(`We now have many sources of revenue.<br>
										PennyEther rewards user to run Tasks that will collect the revenues.<br>
										This ensures revenues are collected autonomously, without owner intervention.`);
							});
						},
						function step13(){
							const pa1Offset = $pa1.offset();
							const pa1Pt = {x: pa1Offset.left, y: pa1Offset.top+30};
							const pa1Width = $pa1.width();
							for (var i=0; i<9; i++) {
								const start = {x: pa1Offset.left + Math.random()*pa1Width, y: pa1Pt.y};
								const stop = {x: start.x, y: start.y-100};
								setTimeout(()=>{
									_sendEth(start, stop, true, true, 10);	
								}, i*200);
							}

							const pa2Offset = $pa2.offset();
							const pa2Pt = {x: pa2Offset.left, y: pa2Offset.top+30};
							const pa2Width = $pa2.width();
							for (var i=0; i<9; i++) {
								const start = {x: pa2Offset.left + Math.random()*pa2Width, y: pa2Pt.y};
								const stop = {x: start.x, y: start.y-100};
								setTimeout(()=>{
									_sendEth(start, stop, true, true, 10);	
								}, i*200);
							}

							const idOffset = $instadice.offset();
							const idPt = {x: idOffset.left, y: idOffset.top+20};
							const idWidth = $instadice.width();
							for (var i=0; i<9; i++) {
								const start = {x: idPt.x + Math.random()*idWidth, y: idPt.y};
								const stop = {x: start.x, y: start.y-100};
								setTimeout(()=>{
									_sendEth(start, stop, true, true, 10);	
								}, i*200);
							}

							wait(2000).then(()=>{
								$txtBalance.addClass("on");
								balance = balance.plus(25e18);
								updateBar();
								return wait(2000);
							}).then(()=>{
								$statusTxt.empty()
									.append(`Let's distribute those profits...`);
								return wait(1000)
							}).then(()=>{
								const invOffset = $investors.offset();
								const invHeight = $investors.height();
								const tokenOffset = $token.offset();
								const tokenPt = {x: tokenOffset.left + 20, y: tokenOffset.top + 10}
								const invPt = {x: invOffset.left + 20, y: tokenPt.y};
								const trPt = {x: tokenPt.x, y: tokenPt.y - 100};
								balance = divThreshold;
								updateBar();
								wait(2000).then(()=>{
									_sendEth(trPt, tokenPt);
									return wait(1000);
								}).then(()=>{
									$txtBalance.removeClass("on");
									for (var i=0; i<20; i++){
										const start = {x: tokenPt.x, y: tokenOffset.top+Math.random()*invHeight};
										const stop = {x: invPt.x, y: start.y};
										setTimeout(()=>{
											_sendEth(start, stop, true, true, 10);
										}, Math.random()*2000)
									}
									return wait(2000);
								}).then(()=>{
									$statusBtn.text("Continue")
									$statusTxt.empty()
										.append(`Profits have been distributed.`);
								})
							});
						},
						function step14(){
							$extra.css({opacity: ".4"});
							$statusBtn.text("Continue");
							$statusTxt.empty()
								.append(`Adding new game types is easy.<br>
									3rd Party Developers can submit games to the PennyEther platform.<br>
									As long as their game sends some of its revenue to Treasury,<br>
									and meets quality standards, the owners will include the game into the UI.`)
						},
						function step14b(){
							$statusBtn.text("Continue");
							$statusTxt.empty()
								.append(`Ideally, a DAO will vote on including new games.<br>
										For now, the owners will code games, and will determine<br>
										which 3rd party games can be included.`);
						},
						function step15(){
							$statusBtn.text("Burn 100 Tokens");
							$statusTxt.empty()
								.append(`Token Holders can burn their tokens at any time.<br>
									They will get a refund of .5 Ether per token, taken from the bankroll.<br>
									<b>Let's see what happens when someone burns 100 Tokens<b>`);
						},
						function step16(){
							$txtBankroll.addClass("on")
							balance = balance.minus(50e18);
							bankroll = bankroll.minus(50e18);
							divThreshold = divThreshold.minus(50e18);
							updateBar();
							wait(2000).then(()=>{
								const invOffset = $investors.offset();
								const invPt = {x: invOffset.left + 20, y: invOffset.top + 20};
								const trPt = {x: invPt.x, y: invPt.y - 100};
								_sendEth(trPt, invPt, true, true);
								return wait(1000);
							}).then(()=>{
								$statusBtn.text("Continue");
								$statusTxt.empty()
									.append(`The bankroll has been reduced by 50 Ether and the Investor has gotten back 50 Ether.<br>
										Since the supply of tokens has decreased, remaining Token Holders<br>
										will receive a higher percentage of each dividend.`);
							});
						},
						function step17(){
							$statusBtn.text("Continue");
							$statusTxt.empty()
								.append(`Since the bankroll has been reduced, so too has the Dividend Threshold.<br>
									The Treasury is still in good health, regardless of having less bankroll.`);
						},
						function step18(){
							$txtBankroll.removeClass("on");
							$statusBtn.text("Reset");
							$statusTxt.empty()
								.append(`That's all.<br>
										For more information, see <a href="/ico/whitepaper.html">the whitepaper</a>.`);
						}
					];

					reset();
				}());
			});
		</script>
		<style>
			#tr-sim {
				margin-top: 20px;
				margin-bottom: 30px;
			}
			#tr-sim .treasury {
				box-sizing: border-box;
				width: 850px;
				padding: 10px;
				margin: 0px auto 0px auto;

				border: 1px solid #444;
				box-shadow: 3px 3px 3px 0px rgba(0,0,0,.2);
				border-radius: 4px;
				background: linear-gradient(to bottom, #EEE 0%, #CCC 100%);
			}
				#tr-sim .treasury .title {
					text-align: center;
					font-weight: bold;
				}
				#tr-sim .treasury .dailyFundingLimit {
					text-align: center;
					display: none;
					font-size: 90%;
					text-shadow: 1px 1px 1px rgba(255,255,255,.4);
				}
				#tr-sim .treasury .dailyFundingLimit span {
					padding: 0px 3px;
					transition: color 1s, background 1s;
				}
			#tr-sim .bar-placeholder {
				height: 60px;
				padding-top: 30px;
			}
			#tr-sim .contracts {
				width: 850px;
				margin: 0px auto;
				margin-top: 20px;
				text-align: left;
			}
			#tr-sim .contract {
				border: 1px solid #444;
				box-shadow: 3px 3px 3px 0px rgba(0,0,0,.2);
				display: inline-block;
				border-radius: 4px;
				background: linear-gradient(to bottom, #EEE 0%, #CCC 100%);
				margin-right: 10px;
				padding: 5px 10px;
				font-size: 80%;
				font-weight: bold;
				opacity: 0;
				transition: opacity 1s, background 1s;
			}
			#tr-sim .contract.show {
				opacity: 1;
			}
			#tr-sim .contract.ended {
				opacity: .5;
				background: linear-gradient(to bottom, #FFE 0%, #FFC 100%);
			}
			#tr-sim .contract > div {
				display: table;
				height: 30px;
			}
			#tr-sim .contract > div > div {
				display: table-cell;
				vertical-align: middle;
				text-align: center;
			}

			#tr-sim .status {
				display: table;
				border-radius: 5px;
				background: rgba(0,0,255,.1);
				border: 1px solid rgba(0,0,255, .3);
				box-shadow: 3px 3px 3px 0px rgba(0,0,0,.05);
				text-shadow: 1px 1px 1px rgba(255,255,255,.4);
				margin-top: 20px;
				transition: opacity 2s;
				max-width: 800px;
			}
			#tr-sim .status .code {
				background: rgba(0,0,255,.5);
				color: white;
			}
			#tr-sim .status .left {
				display: table-cell;
				vertical-align: middle;
				font-size: 90%;
				padding: 10px;
			}
			#tr-sim .status .right {
				display: table-cell;
				vertical-align: middle;
				padding: 2px 10px;
				width: 0px;
				border-left: 1px dotted gray;
			}
			#tr-sim .status button {
				font-size: 120%;
				color: blue;
				cursor: pointer;
				white-space: nowrap;
				transition: opacity .5s;
			}
			#tr-sim .on {
				background: blue;
				color: white;
			}

			#FinanceBar {
				margin: 0px auto;
				width: 80%;
			}
			#FinanceBar .bar {
				border: 1px solid black;
				background: #FAFAFA;
				height: 20px;
			}
			#FinanceBar .balanceBar {
				width: 0%;
				transition: width 2s;
			}

			#FinanceBar .balanceMarker,
			#FinanceBar .bankrollMarker,
			#FinanceBar .divThreshMarker {
				width: 0%;
				border-right: 2px dotted gray;
				transition: width 2s;
			}
			#FinanceBar .balanceMarker {
				border-right: 2px solid black;
			}

			#FinanceBar .balanceTxt,
			#FinanceBar .bankrollTxt,
			#FinanceBar .divThreshTxt {
				font-size: 75%;
				font-weight: bold;
				white-space: nowrap;
				margin-left: -3px;
				left: 0px;
				transition: left 2s, color 1s, background 1s;
			}


			.code {
				padding: 0px 4px;
				background: #E8E8E8;
				font-family: courier;
			}
			.topology {
				position: relative;
				height: 300px;
				width: 100%;
				margin: 40px 0px 80px 0px;
			}

			.topology > div {
				position: absolute;
				box-sizing: border-box;
			}
			.topology > .box {
				z-index: 1;
				border: 1px solid #444;
				box-shadow: 3px 3px 3px 0px rgba(0,0,0,.2);
				display: table;
				border-radius: 4px;
				background: linear-gradient(to bottom, #EEE 0%, #CCC 100%);
			}
			.topology > .line,
			.topology .revenue-label {
				color: rgb(0,100,255);
				font-size: 70%;
				text-align: center;
			}
			.topology > .box > .label {
				display: table-cell;
				vertical-align: middle;
				text-align: center;
				font-weight: bold;
				text-shadow: 1px 1px 1px rgba(255,255,255,.5);
			}
			.topology a {
				color: black;
				text-decoration: none;
				transition: color .3s;
			}
			.topology a:hover {
				color: blue;
				text-decoration: underline;
			}

			.topology .comptroller {
				top: 0px;
				left: 0px;
				height: 50px;
				width: 33%;
			}
			.topology .token {
				top: 70px;
				left: 0px;
				height: 50px;
				width: 33%;
			}
			.topology > .ths {
				top: 150px;
				left: 0px;
				width: 33%;
				height: 100px;
				background: linear-gradient(to bottom, #EFE 0%, #CDC 100%);
			}

			.topology .treasury {
				top: 0px;
				left: 45%;
				width: 45%;
				height: 120px;
			}
			.topology .mc {
				top: 150px;
				left: 45%;
				height: 100px;
				width: 18%;
			}
			.topology > .games {
				top: 150px;
				left: 75%;
				height: 100px;
				width: 15%;
				background: #DDD;
				border: none;
				border-radius: 3px;
			}
			.topology > .games > .title {
				position: absolute;
				width: 100%;
				text-align: center;
				top: -15px;
				font-size: 70%;
				color: gray;
			}
			.topology > .games .game {
				margin: 5px;
				padding: 5px;
				font-size: 80%;
				border-radius: 4px;
				background: #FAFAFA;
				border: 1px outset #DDD;
			}
			.topology .games .other {
				opacity: .5;
			}

			.topology .comptroller-treasury {
				top: 10px;
				left: 33%;
				width: 12%;
				border-bottom: 1px dotted gray;
			}
			.topology .token-treasury {
				top: 80px;
				left: 33%;
				width: 12%;
				border-bottom: 1px dotted gray;
			}
			.topology .mc-treasury {
				padding-top: 7px;
				top: 120px;
				left: 50%;
				height: 30px;
				border-left: 1px dotted gray;
			}
			.topology .mc-games {
				top: 190px;
				left: 63%;
				width: 12%;
				border-bottom: 1px dotted gray;
			}
			.topology .game-1-line {
				left: 90%;
				top: 167px;
				width: 7%;
				border-bottom: 1px dotted gray;
			}
			.topology .game-2-line {
				left: 90%;
				top: 197px;
				width: 7%;
				border-bottom: 1px dotted gray;
			}
			.topology .game-3-line {
				left: 90%;
				top: 230px;
				width: 7%;
				border-bottom: 1px dotted gray;
			}
			.topology .revenue-up-line {
				left: 97%;
				top: 60px;
				height: 170px;
				border-left: 1px dotted gray;
			}
			.topology .revenue-tr-line {
				left: 90%;
				width: 7%;
				top: 60px;
				border-bottom: 1px dotted gray;
			}
			.topology .revenue-label {
				left: 90%;
				top: 45px;
				padding-left: 5px;
			}
			.topology .burning-line {
				top: 195px;
				left: 31%;
				width: 150px;
				transform-origin: 0px 0px;
				border-bottom: 1px dotted gray;
				transform: rotate(-40deg);
			}
			.topology .dividends-line {
				top: 120px;
				left: 15%;
				height: 40px;
				padding-top: 10px;
				border-left: 1px dotted gray;
			}

			.dao {
				top: 280px;
				height: 30px;
				left: 0%;
				width: 90.3%;
				opacity: .5;
			}
			.voting-line {
				top: 250px;
				height: 30px;
				left: 15%;
				padding-top: 10px;
				border-left: 1px dotted gray;
				opacity: .5;
			}
			.settings-line {
				top: 250px;
				height: 30px;
				left: 50%;
				padding-top: 10px;
				border-left: 1px dotted gray;
				opacity: .5;
			}
			.newgame-line {
				top: 250px;
				height: 30px;
				left: 77%;
				padding-top: 10px;
				border-left: 1px dotted gray;
				opacity: .5;
			}
		</style>
	</head>
	<body><div id="Content">
		<div class="main">
			<div class="section pageTitle">
				PennyEther
			</div>
			<div style="padding: 0px 40px">
				<p>
					PennyEther is an experiment. What started as a little Ethereum side-project has grown into a full-time devotion to creating a fair, autonomous, revenue-generating blockchain application. It's our way of pushing the limits of Ethereum, and economics, to see just how feasible the dream of a "pure" DAO is.
				</p>
				<p>
					This article goes over the basics -- a lot more can be found in <a href="/ico/whitepaper.html" target="_blank">our whitepaper</a>.
				</p>

				<div class="subsection">
					<div class="head">Our Goals</div>
					<div class="body">
						<p>
							We decided very early on that our focus was technology, and not marketing. Our team members are technically minded, and we're all fatigued by the current ICO and crypto market -- it's endless hype, endless promises, and endless scandal. We want no part in that, though we <i>do</i> want to garner enough interest in our experiement to give it a shot at success.
						</p>
						<p>
							We are much more interested in building and earning revenue from a working product. Partly there's the dream of earning a sizeable passive income, but mostly there's a strong desire to create a fully-fledged blockchain application. We've seen very few projects developed past a prototype or simulated screen-grab, and we want to break new ground.
						</p>
						<p>
							We decided early on to not go public until our product is ready. And here we are.
						</p>		
					</div>
				</div>
				
				<div class="subsection">
					<div class="head">What Penny Ether Is</div>
					<div class="body">
						<h3>High-Level Demo</h3>
						<div id="tr-sim">
							<div class="treasury">
								<div class="title">Treasury</div>
								<div class="bar-placeholder"></div>
								<div class="dailyFundingLimit">
									<span class="label">dailyFundingLimit:</span>
									<span class="value">0 Ether</span>
								</div>
							</div>
							<div class="contracts">
								<div class="contract crowdsale">
									<div>
										<div>CrowdSale</div>
									</div>
								</div>
								<div class="contract investors">
									<div>
										<div>Investors</div>
									</div>
								</div>
								<div class="contract token">
									<div>
										<div>DividendToken</div>
									</div>
								</div>
								<div class="contract pennyauction1">
									<div>
										<div>Penny Auction #1</div>
									</div>
								</div>
								<div class="contract pennyauction2">
									<div>
										<div>Penny Auction #2</div>
									</div>
								</div>
								<div class="contract instadice">
									<div>
										<div>InstaDice</div>
									</div>
								</div>
								<div class="contract extra">
									<div>
										<div>3rd Party<br>Games</div>
									</div>
								</div>
							</div>
							<div style="text-align: center;">
								<div style="display: inline-block;">
									<div class="status">
										<div class="left">
											Test status goes here
										</div>
										<div class="right">
											<button>Do Stuff</button>
										</div>
									</div>
								</div>
							</div>
						</div>

						<h3>The Core Structure</h3>
						<p>
							PennyEther is a blockchain application that autonomously earns revenue by running games on the blockchain. Token Holders own the rights to all profits. Each token is backed by .5 Ether in the Treasury bankroll, so Token Holders can burn their tokens at any time to get .5 Ether per Token. All revenues generated by PennyEther are sent to the Treasury. If the Treasury has a profit, it will immediately distribute it proportionally to all Token Holders, who can then claim their share of dividends, at any time, forever, and even if they transfer their tokens.
						</p>
						<p>
							The MainController manages and funds all games, and is the only contract the Treasury can send Ether to. For example, a Penny Auction requires Ether to be started - so the MainController will get funding from the Treasury and send it to the new Penny Auction. The Treasury will only fund the MainController a (relatively small) amount per day: <span class="code">dailyFundingLimit</span>. Therefore, the loss of <span class="code">dailyFundingLimit</span> per day is the worst-case scenario for PennyEther.
						</p>
						<p>
							The Treasury protects Token Holders' .5 Ether by having a buffer between the balance required to pay dividends, and the balance required to burn all tokens. This buffer is <span class="code">14 days * dailyFundingLimit</span>. This means that in the worst-case of the Treasury losing <span class="code">dailyFundingLimit</span> per day, Token Holders' .5 Ether will be safe for at least 14 days. Token Holders can monitor the Treasury via the blockchain, or through the <a href="/status/token">Treasury UI</a>.
						</p>
						<p>
							All of the above happens autonomously, and cannot ever be altered by anyone. There is no way to get Ether out of the Treasury other than to burn Tokens, or to fund games (limited by <span class="code">dailyFundingLimit</span>). There are no "emergency" systems in place to prevent dividends from being distributed, or to prevent tokens from being burned, or to remove funds from the Treasury. And you don't have to take our word for it - the source code is public, and we're having it audited.
						</p>
						<p>
							Our whitepaper contains <a href="/ico/whitepaper.html#application-demo" target="_blank">an interactive demo</a> which helps visualize how Ether flows through PennyEther.
						</p>

						<h3>Operations</h3>
						<p>
							Currently, the owners (PennyEther Team) control which games are added and removed, as well as the games' settings. It's in the owners' best interests to have the games be as profitable as possible, since the owners themselves hold a fixed 10% share of the profits, plus 10% of the tokens minted. Our team have deployed two games which are running and profitable; details about those games are further below.
						</p>
						<p>
							In the future, we hope to have the adding and removing of games be autonomously decided by Token Holders. Ideally, Token Holders could vote on if some new deployed game should be included in PennyEther. A successful vote would autonomously upgrade PennyEther to incorporate the new game, and the open-sourced UI would be updated to interface with it. Likewise, Token Holders should be able to collectively act as the admin. They should have the ability to vote on the settings and parameters of games (such as Penny Auction settings).
						</p>
						<p>
							Finally, PennyEther requires certain contract functions to be called periodically to keep it running smoothly. For example, a new Penny Auction may need to be started, or profits from some games may need to be sent to the Treasury. In order to ensure autonomy, these function calls are called Tasks - any user can call them and receive a small reward for doing so. We've made a <a href="/games/tasks" target="_blank">Task UI</a> to ensure these tasks are completed.
						</p>

						<h3>Apps</h3>
						<p>
							One future idea we'd like to explore is becoming a conglomerate.
						</p>
						<p>
							PennyEther can profit from any type of contract, and not just games. Essentially anything that generates revenue and wishes to leverage the PennyEther framework and audience could be part of the PennyEther umbrella, even if developed by 3rd parties. All that is needed is a deployed contract that sends some share of revenues to the Treasury, a UI, and for Token Holders to vote on it.
						</p>
						<p>
							App developers may choose to code their contract however they please - their contract does not necessary have to send 100% of its profits to PennyEther. However, if the develepers are too greedy, or if the proposed contract lacks the assurance that it will be profitable, Token Holders will not vote to include it in PennyEther. Likewise, if the contract fails to deliver profits or runs at a loss, Token Holders may vote to disable it. In either case, the largest loss PennyEther may suffer is limited to <span class="code">dailyFundingLimit</span> per day.
						</p>
						<h3>Conclusion</h3>
						<p>
							That's basically PennyEther. While it's not yet fully autonomous, the core is in place, as well as two deployed games. We think that's progress. Here's a diagram:
						</p>
						<div class="topology">
							<div class="comptroller box" style="display: table;">
								<div class="label">
									<a href="/about/contracts.html#comptroller" target="_blank">CrowdSale</a>
								</div>
							</div>
							<div class="token box">
								<div class="label">
									<a href="/about/contracts.html#dividend-token" target="_blank">DividendToken</a>
								</div>
							</div>
							<div class="ths box">
								<div class="label">Token Holders</div>
							</div>
							<!-- <div class="th1 box"></div>
							<div class="th2 box"></div>
							<div class="th3 box"></div>
							<div class="th4 box"></div> -->
							<div class="treasury box">
								<div class="label">
									<a href="/about/contracts.html#treasury" target="_blank">Treasury</a>
								</div>
							</div>
							<div class="mc box">
								<div class="label">
									<a href="/about/contracts.html#main-controller" target="_blank">MainController</a>
								</div>
							</div>
							<div class="games box container">
								<div class="title">Games</div>
								<div class="game game-1">
									<a href="/about/contracts.html#penny-auction" target="_blank">Penny Auctions</a>
								</div>
								<div class="game game-2">
									<a href="/about/contracts.html#instadice">InstaDice</a>
								</div>
								<div class="game other">Coming soon...</div>
							</div>
							<div class="dao box">
								<div class="label">
									DAO*
									<span style="font-size: 50%; color: gray; position: absolute; right: 4px; bottom: 2px;">* not yet implemented</span>
								</div>
							</div>
							<div class="comptroller-treasury line">
								<span class="tipLeft" title="The CrowdSale provides Treasury with its initial bankroll. All tokens are backed by .5 Ether.">Bankroll ⇨</span>
							</div>
							<div class="token-treasury line">
								<span class="tipRight" title="When Treasury has a surplus of Ether, profits are sent to the DividendToken.">⇦ Profits</span>
							</div>
							<div class="mc-treasury line">
								&nbsp;<span class="tipRight" title="The Treasury can fund MainController a limited amount per day.">⇩ Funding</span>
								<span style="color: gray; font-style: italic;">[limited per day]</span>
							</div>
							<div class="mc-games line">
								<span class="tipLeft" title="Some games, like Penny Auctions, require Ether to start.">Funding ⇨</span>
							</div>
							<div class="game-1-line"></div>
							<div class="game-2-line"></div>
							<div class="game-3-line"></div>
							<div class="revenue-up-line"></div>
							<div class="revenue-tr-line"></div>
							<div class="revenue-label">
								<span class="tipRight" title="Revenue trickles in from games.">⇦ Revenue</div>
							<div class="burning-line line">
								<span class="tipRight" title="If PennyEther is failing, Token Holders can burn tokens to receive .5 Ether per token." style="color: red;">⇦ Refund</span>
							</div>
							<div class="dividends-line line">
								<span class="tipRight" title="Any Ether sent to DividendToken is distributed proportionally at the time it is received. Token Holders can claim their dividends at any time, even if they burn or transfer their tokens.">&nbsp;⇩ Dividends</span>
							</div>
							<div class="voting-line line">
								<span class="tipRight" title="Token Holders will be able to vote on new games and PennyEther settings." style="color: green;">&nbsp;⇩ Voting</span>
							</div>
							<div class="settings-line line">
								<span class="tipRight" title="The DAO will be able to change PennyEther settings." style="color: green;">&nbsp;⇧ Settings</span>
							</div>
							<div class="newgame-line line">
								<span class="tipRight" title="The DAO will be able to deploy new games." style="color: green;">&nbsp;⇧ New Games</span>
							</div>
						</div>

					</div>
				</div>

				<div class="subsection">
					<div class="head">What PennyEther Isn't</div>
					<div class="body">
						<p>
							We much prefer to focus on technology and development than on convincing people that they'll get rich. Even our gaming pages reflect this -- we're not promising riches to our players, but simply a fair and (hopefully) fun way to use their Ether.
						</p>
						<p>
							You may have already noticed our lack-luster landing page, rather plain and technical white-paper, and an overall lack of marketing. We don't have a Chief Marketing Officer, and if we did, we'd frankly be too embarrassed to admit it. We prefer to spend our effort improving our product rather than improving our image, because the whole point of PennyEther is to see just how far we can push towards a pure DAO.
						</p>
						<p>
							If you're in crypto to play the hype game, PennyEther is probably not the coin for you, at least until the day comes where completed products that produce revenue become the new hype. Of course, you're more than welcome to try out our games.
						</p>
					</div>
				</div>

				<div class="subsection">
					<div class="head">Games</div>
					<div class="body">
						<h3>Penny Auctions</h3>
						<p>
							A Penny Auction is a type of game where there is a prize, a current winner, and a countdown. When the countdown reaches zero, the current winner receives the prize. To become the current winner, one must send some fixed amount of Ether, typically much less than the prize, to the auction. This will set that user as the current winner and extend the countdown by some time. That user will win unless another person bids before the countdown expires.
						</p>
						<p>
							Classically, there was no way to hold Penny Auctions fairly. The owner of the auction could bid on the auction for free -- when they send the bid fee to the auction, the owner immediately gets their money right back. The owner could guarantee profitability by always bidding after another user. This problem is called "shill bidding" or "bid botting".
						</p>
						<p>
							However, PennyEther solves this problem: The bid fees don't go back to the owner -- they go to the Token Holders, which are distributed. There is no one Token Holder that owns enough tokens to recoupeate their entire bid fee, so there can be no shill bidding. The worst case is that a Token Holder can receive a small discount in bidding, since they will receive some percentage of it back in dividends.
						</p>
						<p>
							Classically, one had to trust the owners of the Penny Auction to actually send the prize. This, too, is solved, because the Penny Auction is a smart contract. The prize will go the winner, and nobody else, and nothing can prevent that from happening short of the Ethereum network going down.
						</p>
						<p>
							<a href="/ico/whitepaper.html#games-penny-auctions">Much more about Penny Auctions can be found in our whitepaper.</a>							
						</p>

						<h3>InstaDice</h3>
						<p>
							InstaDice is like simplified roulette. Users can choose their own odds (or, inversely, payout multiple), and roll a 100 sided die. For example, a user may choose to win on 20 or below, for a payout of roughly 5x.
						</p>
						<p>
							There's nothing innately novel about this game. Blockchain dice games have been around since the 2012. However, our game shows the user their results in one Ethereum block -- around 15-30 seconds -- which is currently the fastest turn around time of any blockchain dice game. We think that's a good differentiator.  
						</p>
						<p>
							Also our UI, though admittedly plain, is arguably the best one out there: we allow the user easily and plainly see thier wager parameters, allow them to choose their own gas price, show the transaction progress, and make all internal details of the roll available to the user.
						</p>
						<p>
							<a href="/ico/whitepaper.html#games-instadice">Much more about InstaDice can be found in our whitepaper.</a>		
						</p>
					</div>
				</div>
			</div>
		</div>
	</div></body>
</html>